{"ast":null,"code":"function dijkstra(grid, start, finish) {\n  const visitedInOrder = [];\n  start.distance = 0;\n  const unvisited = allNodes(grid);\n  while (unvisited.length) {\n    sortNodes(unvisited);\n    const closest = unvisited.shift();\n    if (closest === finish) {\n      return visitedInOrder;\n    }\n    if (closest.isWall) continue;\n    if (closest.distance === Infinity) return visitedInOrder;\n    closest.isVisited = true;\n    visitedInOrder.push(closest);\n    updateUnvisitedNeighbors(closest, grid);\n  }\n  return visitedInOrder;\n}\nfunction DFS(grid, start, finish) {\n  const visitedInOrder = [];\n  let unvisited = [];\n  unvisited.push(start);\n  while (unvisited.length) {\n    const node = unvisited.pop();\n    if (node === finish) {\n      return visitedInOrder;\n    }\n    if (node.isWall) continue;\n    node.isVisited = true;\n    visitedInOrder.push(node);\n    unvisited = unvisited.concat(getUNeighbors(node, grid));\n  }\n  return visitedInOrder;\n}\n_c = DFS;\nfunction BFS(grid, start, finish) {\n  const visitedInOrder = [];\n  let unvisited = [];\n  unvisited.push(start);\n  while (unvisited.length) {\n    const node = unvisited.shift();\n    if (node === finish) {\n      return visitedInOrder;\n    }\n    if (node.isWall) continue;\n    node.isVisited = true;\n    visitedInOrder.push(node);\n    unvisited = unvisited.concat(getUNeighbors(node, grid));\n  }\n  return visitedInOrder;\n}\n_c2 = BFS;\nfunction getUNeighbors(node, grid) {\n  const neighbors = [];\n  const reN = [];\n  const {\n    row,\n    col\n  } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  for (let index = 0; index < neighbors.length; index++) {\n    const neighbor = neighbors[index];\n    if (!neighbor.isVisited) {\n      neighbor.previousNode = node;\n      neighbor.isVisited = true;\n      reN.push(neighbor);\n    }\n  }\n  return reN;\n}\nfunction AStar(grid, start, finish) {\n  const visitedInOrder = [];\n  start.distance = 0;\n  start.heuristic = 0;\n  const unvisited = allNodes(grid);\n  while (unvisited.length) {\n    sortNodesStar(unvisited);\n    const cur = unvisited.shift();\n    if (cur === finish) {\n      return visitedInOrder;\n    }\n    if (cur.isWall) continue;\n    if (cur.distance + cur.heuristic === Infinity) return visitedInOrder;\n    cur.isVisited = true;\n    visitedInOrder.push(cur);\n    updateUnvisitedNeighborsStar(cur, grid, finish);\n  }\n  return visitedInOrder;\n}\n_c3 = AStar;\nfunction updateUnvisitedNeighborsStar(cur, grid, finish) {\n  const neighbors = [];\n  const {\n    row,\n    col\n  } = cur;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  for (const neighbor of neighbors) {\n    if (!neighbor.isVisited) {\n      neighbor.distance = cur.distance + 1;\n      neighbor.heuristic = manhattanDistance(neighbor, finish);\n      neighbor.previousNode = cur;\n    }\n  }\n}\nfunction manhattanDistance(a, b) {\n  let {\n    row: ar,\n    col: ac\n  } = a;\n  let {\n    row: br,\n    col: bc\n  } = b;\n  return Math.abs(ar - br) + Math.abs(ac - bc);\n}\nfunction allNodes(grid) {\n  const re = [];\n  for (const row of grid) {\n    for (const node of row) {\n      re.push(node);\n    }\n  }\n  return re;\n}\nfunction sortNodesStar(nodes) {\n  nodes.sort((a, b) => a.distance + a.heuristic - (b.distance + b.heuristic));\n}\nfunction sortNodes(nodes) {\n  nodes.sort((a, b) => a.distance - b.distance);\n}\nfunction updateUnvisitedNeighbors(closest, grid) {\n  const neighbors = [];\n  const {\n    row,\n    col\n  } = closest;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  for (const neighbor of neighbors) {\n    if (!neighbor.isVisited) {\n      neighbor.distance = closest.distance + 1;\n      neighbor.previousNode = closest;\n    }\n  }\n}\nfunction getShortestPath(finish) {\n  const path = [];\n  let cur = finish;\n  while (cur !== null) {\n    path.unshift(cur);\n    cur = cur.previousNode;\n  }\n  return path;\n}\nfunction randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\nfunction primMaze(grid) {\n  let sr = 7,\n    sc = 17; // set a starting point for generating maze\n  let height = grid.length,\n    width = grid[0].length;\n  for (let i = 0; i < height; i++) {\n    for (let j = 0; j < width; j++) {\n      makeWall(grid, i, j, false);\n    }\n  }\n  for (let i = 0; i < height; i++) {\n    for (let j = i % 2 + 1; j < width; j += i % 2 + 1) {\n      makeWall(grid, i, j, true);\n    }\n  }\n  for (let i = 0; i < height; i++) {\n    makeWall(grid, i, 0, true);\n  }\n  let visited = [];\n  let path = [{\n    row: sr,\n    col: sc\n  }];\n  while (path.length > 0) {\n    const index = randomSelect(path);\n    const node = path[index];\n    path.splice(index, 1);\n    visited = visited.concat([node]);\n    const {\n      c: connected,\n      u: unconnected\n    } = getNeighbors(grid, visited, node);\n    if (connected.length > 0) {\n      let rn = randomSelect(connected);\n      connect(grid, node, connected[rn]);\n      connected.splice(rn);\n    }\n    path = path.concat(unconnected);\n  }\n}\nfunction randomSelect(path) {\n  return randomInt(0, path.length - 1);\n}\nfunction validate(grid, points) {\n  let height = grid.length,\n    width = grid[0].length;\n  let pRe = [];\n  for (let index = 0; index < points.length; index++) {\n    let {\n      row,\n      col\n    } = points[index];\n    if (0 <= row && row < height && 0 <= col && col < width) {\n      pRe.push(points[index]);\n    }\n  }\n  return pRe;\n}\nfunction isVisited(visited, node) {\n  let {\n    row: nr,\n    col: nc\n  } = node;\n  for (let index = 0; index < visited.length; index++) {\n    let {\n      row: ir,\n      col: ic\n    } = visited[index];\n    if (nr === ir && nc === ic) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getNeighbors(grid, visited, node) {\n  let {\n    row,\n    col\n  } = node;\n  let neighbors = [{\n    row: row + 2,\n    col: col\n  }, {\n    row: row - 2,\n    col: col\n  }, {\n    row: row,\n    col: col + 2\n  }, {\n    row: row,\n    col: col - 2\n  }];\n  neighbors = validate(grid, neighbors.slice());\n  let connected = [];\n  let unconnected = [];\n  neighbors.forEach(neighbor => {\n    if (isVisited(visited, neighbor)) {\n      connected.push(neighbor);\n    } else {\n      unconnected.push(neighbor);\n    }\n  });\n  return {\n    c: connected,\n    u: unconnected\n  };\n}\nfunction connect(grid, a, b) {\n  let {\n    row: ar,\n    col: ac\n  } = a;\n  let {\n    row: br,\n    col: bc\n  } = b;\n  let row = (ar + br) / 2;\n  let col = (ac + bc) / 2;\n  makeWall(grid, row, col, false);\n}\nfunction makeWall(grid, row, col, isW) {\n  const node = grid[row][col];\n  const newNode = {\n    ...node,\n    isWall: isW\n  };\n  grid[row][col] = newNode;\n}\nexport { dijkstra, BFS, DFS, AStar, getShortestPath, primMaze };\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"DFS\");\n$RefreshReg$(_c2, \"BFS\");\n$RefreshReg$(_c3, \"AStar\");","map":{"version":3,"names":["dijkstra","grid","start","finish","visitedInOrder","distance","unvisited","allNodes","length","sortNodes","closest","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbors","DFS","node","pop","concat","getUNeighbors","_c","BFS","_c2","neighbors","reN","row","col","index","neighbor","previousNode","AStar","heuristic","sortNodesStar","cur","updateUnvisitedNeighborsStar","_c3","manhattanDistance","a","b","ar","ac","br","bc","Math","abs","re","nodes","sort","getShortestPath","path","unshift","randomInt","min","max","floor","random","primMaze","sr","sc","height","width","i","j","makeWall","visited","randomSelect","splice","c","connected","u","unconnected","getNeighbors","rn","connect","validate","points","pRe","nr","nc","ir","ic","slice","forEach","isW","newNode","$RefreshReg$"],"sources":["E:/sanskruti/Path and Sorting Visualizer/sans/path-and-sort/src/Algorithm/pathfindingAlgorithms.js"],"sourcesContent":["\nfunction dijkstra(grid, start, finish) {\n    const visitedInOrder = [];\n    start.distance = 0;\n    const unvisited = allNodes(grid);\n    while (unvisited.length) {\n        sortNodes(unvisited);\n        const closest = unvisited.shift();\n        if (closest === finish) {\n            return visitedInOrder;\n        }\n        if (closest.isWall) continue;\n        if (closest.distance === Infinity) return visitedInOrder;\n        closest.isVisited = true;\n        visitedInOrder.push(closest);\n\n        updateUnvisitedNeighbors(closest, grid);\n    }\n    return visitedInOrder;\n}\n\nfunction DFS(grid, start, finish) {\n    const visitedInOrder = [];\n    let unvisited = [];\n    unvisited.push(start);\n    while (unvisited.length) {\n        const node = unvisited.pop();\n        if (node === finish) {\n            return visitedInOrder;\n        }\n        if (node.isWall) continue;\n        node.isVisited = true;\n        visitedInOrder.push(node);\n\n        unvisited = unvisited.concat(getUNeighbors(node, grid));\n    }\n\n    return visitedInOrder;\n}\n\nfunction BFS(grid, start, finish) {\n    const visitedInOrder = [];\n    let unvisited = [];\n    unvisited.push(start);\n    while (unvisited.length) {\n        const node = unvisited.shift();\n        if (node === finish) {\n            return visitedInOrder;\n        }\n        if (node.isWall) continue;\n        node.isVisited = true;\n        visitedInOrder.push(node);\n\n        unvisited = unvisited.concat(getUNeighbors(node, grid));\n    }\n\n    return visitedInOrder;\n}\n\nfunction getUNeighbors(node, grid) {\n    const neighbors = [];\n    const reN = [];\n    const { row, col } = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n\n    for (let index = 0; index < neighbors.length; index++) {\n        const neighbor = neighbors[index];\n        if (!neighbor.isVisited) {\n            neighbor.previousNode = node;\n            neighbor.isVisited = true;\n            reN.push(neighbor);\n        }\n    }\n    return reN;\n\n}\n\nfunction AStar(grid, start, finish) {\n    const visitedInOrder = [];\n    start.distance = 0;\n    start.heuristic = 0;\n    const unvisited = allNodes(grid);\n    while (unvisited.length) {\n        sortNodesStar(unvisited);\n        const cur = unvisited.shift();\n        if (cur === finish) {\n            return visitedInOrder;\n        }\n        if (cur.isWall) continue;\n        if (cur.distance + cur.heuristic === Infinity) return visitedInOrder;\n        cur.isVisited = true;\n        visitedInOrder.push(cur);\n\n        updateUnvisitedNeighborsStar(cur, grid, finish);\n    }\n    return visitedInOrder;\n}\n\nfunction updateUnvisitedNeighborsStar(cur, grid, finish) {\n    const neighbors = [];\n    const { row, col } = cur;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    for (const neighbor of neighbors) {\n        if (!neighbor.isVisited) {\n            neighbor.distance = cur.distance + 1;\n            neighbor.heuristic = manhattanDistance(neighbor, finish);\n            neighbor.previousNode = cur;\n        }\n    }\n}\n\nfunction manhattanDistance(a, b) {\n    let { row: ar, col: ac } = a;\n    let { row: br, col: bc } = b;\n    return Math.abs(ar - br) + Math.abs(ac - bc);\n}\n\nfunction allNodes(grid) {\n    const re = [];\n    for (const row of grid) {\n        for (const node of row) {\n            re.push(node);\n        }\n    }\n    return re;\n}\n\nfunction sortNodesStar(nodes) {\n    nodes.sort((a, b) => (a.distance + a.heuristic) - (b.distance + b.heuristic));\n}\n\n\nfunction sortNodes(nodes) {\n    nodes.sort((a, b) => a.distance - b.distance);\n}\n\nfunction updateUnvisitedNeighbors(closest, grid) {\n    const neighbors = [];\n    const { row, col } = closest;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    for (const neighbor of neighbors) {\n        if (!neighbor.isVisited) {\n            neighbor.distance = closest.distance + 1;\n            neighbor.previousNode = closest;\n        }\n    }\n}\n\nfunction getShortestPath(finish) {\n    const path = [];\n    let cur = finish;\n    while (cur !== null) {\n        path.unshift(cur);\n        cur = cur.previousNode;\n    }\n    return path;\n}\n\nfunction randomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nfunction primMaze(grid) {\n    let sr = 7, sc = 17; // set a starting point for generating maze\n    let height = grid.length, width = grid[0].length;\n    for (let i = 0; i < height; i++) {\n        for (let j = 0; j < width; j++) {\n            makeWall(grid, i, j, false);\n        }\n\n    }\n    for (let i = 0; i < height; i++) {\n        for (let j = i % 2 + 1; j < width; j += i % 2 + 1) {\n            makeWall(grid, i, j, true);\n        }\n    }\n    for (let i = 0; i < height; i++) {\n        makeWall(grid, i, 0, true);\n    }\n    let visited = [];\n    let path = [{ row: sr, col: sc }];\n    while (path.length > 0) {\n        const index = randomSelect(path);\n        const node = path[index];\n        path.splice(index, 1);\n        visited = visited.concat([node]);\n        const { c: connected, u: unconnected } = getNeighbors(grid, visited, node);\n        if (connected.length > 0) {\n            let rn = randomSelect(connected);\n            connect(grid, node, connected[rn]);\n            connected.splice(rn);\n        }\n        path = path.concat(unconnected);\n\n    }\n}\n\nfunction randomSelect(path) {\n    return randomInt(0, path.length - 1);\n}\n\nfunction validate(grid, points) {\n    let height = grid.length, width = grid[0].length;\n    let pRe = [];\n    for (let index = 0; index < points.length; index++) {\n        let { row, col } = points[index];\n        if ((0 <= row && row < height && 0 <= col && col < width)) {\n            pRe.push(points[index]);\n        }\n    }\n    return pRe;\n\n}\n\nfunction isVisited(visited, node) {\n    let { row: nr, col: nc } = node;\n    for (let index = 0; index < visited.length; index++) {\n        let { row: ir, col: ic } = visited[index];\n        if (nr === ir && nc === ic) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction getNeighbors(grid, visited, node) {\n    let { row, col } = node;\n    let neighbors = [{ row: row + 2, col: col }, { row: row - 2, col: col }, { row: row, col: col + 2 }, { row: row, col: col - 2 }];\n    neighbors = validate(grid, neighbors.slice());\n    let connected = [];\n    let unconnected = [];\n    neighbors.forEach(neighbor => {\n        if (isVisited(visited, neighbor)) {\n            connected.push(neighbor);\n        }\n        else {\n            unconnected.push(neighbor);\n        }\n    });\n    return { c: connected, u: unconnected };\n}\n\nfunction connect(grid, a, b) {\n    let { row: ar, col: ac } = a;\n    let { row: br, col: bc } = b;\n    let row = (ar + br) / 2;\n    let col = (ac + bc) / 2;\n    makeWall(grid, row, col, false);\n}\n\nfunction makeWall(grid, row, col, isW) {\n    const node = grid[row][col];\n    const newNode = {\n        ...node,\n        isWall: isW,\n    }\n    grid[row][col] = newNode;\n}\n\nexport { dijkstra, BFS, DFS, AStar, getShortestPath, primMaze };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}